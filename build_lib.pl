#!/usr/bin/perl -w

$INDEX = 0;
%STRINGS = ();
%LIB = ();
$LIBNAME = "";

%TYPEMAP=(
    "func" => "LUA_VCCL",
    "table" => "LUA_TTABLE",
    "string" => "LUA_VSHRSTR",
    "float" => "LUA_VNUMFLT",
    "integer" => "LUA_VNUMINT",
);
    
open(FH_MAIN, ">ro_main.h") or die $!;
print FH_MAIN "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n\n";

# ------------------------------------------------------------------------------
# Find the minimum and maximum length of the supplied array items
# ------------------------------------------------------------------------------
sub minmax {
    my $min = 999;
    my $max = 0;
    foreach(@_) {
        $min = length($_) if length($_) < $min;
        $max = length($_) if length($_) > $max;
    }
    return ($min, $max);
}
# ------------------------------------------------------------------------------
# Adds an entry to the overall string list, note it must not replace existing
# entries mainly because the token numbers need to survive in the list lookups
# ------------------------------------------------------------------------------
sub add_string {
    my $string = shift @_;
    my $index = shift @_;

    $STRINGS{$string} = { "index"=>$index } if not exists $STRINGS{$string};
}

# ------------------------------------------------------------------------------
# Reads tokens from a list within a C source file, if $tok is defined then the
# output will include an incrementing token number.
# ------------------------------------------------------------------------------
sub _READWORDS {
    my $file = shift @_;
    my $match = shift @_;
    my $tok = shift @_ or 0;

    open(FH, $file) or die $!;
    while(<FH>) {
        last if($_ =~ /\Q$match\E/);
    }
    my $code = "(";
    while(<FH>) {
        last if (/};/);
        $code .= $_;
    }
    close(FH);
    $code .= ");";
    my @res = eval($code) or die $!;

    #
    # Now we can add each string to our strings list (this will uniq them)
    #
    foreach my $k (@res) {
        printf(FH_MAIN "const ro_TString ros%03d = ROSTRING(\"$k\", $tok, 0, NULL);\n", $INDEX);
        $tok++ if($tok > 0);
        add_string($k, $INDEX++);
    }
}
sub READ_TOKENS {
    return _READWORDS("src/llex.c", "luaX_tokens [] =", 1);
}
sub READ_WORDS {
    return _READWORDS(shift @_, shift @_, 0);
}

# ------------------------------------------------------------------------------
# Reads the strings and functions from the lib source file and stores them in the
# global LIB array (which is zeroed at the start)
# ------------------------------------------------------------------------------
sub READ_LIB {
    my $name = shift @_;
    my $file = shift @_;
    my $match = shift @_;

    %LIB = ();
    $LIBNAME = $name;
    open(FH, $file) or die $!;
    while(<FH>) {
        last if ($_ =~ /\Q$match\E/);
    }
    while(<FH>) {
        last if /};/;
        if ( $_ =~ /"([^"]+)",\s+(\w+)/ ) {
            $LIB{$1} = { "type"=>"func", "item"=>$2 }
        }
    }
    close(FH);
}
# ------------------------------------------------------------------------------
# Functions for adding and removing lib items
# ------------------------------------------------------------------------------
sub ADD_FUNC {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"func", "item"=>$item };
}
sub ADD_FLOAT {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"float", "item"=>$item };
}
sub ADD_INT {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"integer", "item"=>$item };
}
#sub ADD_TABLE {
#    my ($name, $item) = @_;
#    $LIB{$name} = { "type"=>"table", "item"=>$item };
#}
sub ADD_GLOBAL_TABLE {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"table", "item"=>$item };
}
# ------------------------------------------------------------------------------
# Process an item in a LIB handling the different types and the creation of other
# objects if needed
# ------------------------------------------------------------------------------
sub process_item {
    my $name = shift @_;
    my $count = keys %LIB;
    my $type = $TYPEMAP{$LIB{$name}{"type"}} or 0;
    my $item = $LIB{$name}{"item"};
    $LIB{$name}{"index"} = $INDEX;
    my $cvar = sprintf("ros%03d", $INDEX);
   
    if ($type eq "LUA_VNUMFLT") {
        printf(FH_LIB "const lua_Number ${cvar}_item = ${item};\n");
        $item = "&${cvar}_item";
    } elsif ($type eq "LUA_VNUMINT") {
        $item = "(void *)$item";
    } elsif ($type eq "LUA_TTABLE") {
        # Always in the main file...
        printf(FH_MAIN "const ro_TString ros%03d = ROSTRING(\"${name}\", 0, $type, &ro_table_$item);\n", $INDEX);
        $item = "&${name}";
    }
    if ($type ne "LUA_TTABLE") {
        printf(FH_LIB "extern const ro_TString ros%03d;\n", $INDEX);
        printf(FH_LIB "const ro_TString ros%03d = ROSTRING(\"${name}\", 0, $type, $item);\n", $INDEX);
        printf(FH_MAIN "extern const ro_TString ros%03d;\n", $INDEX);
    }
}

# ------------------------------------------------------------------------------
# Output a list of ros items in sorted order in a nice C friendly way
# ------------------------------------------------------------------------------
sub output_list {
    my ($FH) = shift @_;
    my (@list) = @_;
    my $n = 0;
    foreach my $index (@list) {
        print($FH "\t") if ($n % 8 == 0);
        printf($FH "&ros%03d, ", $index);
        print($FH "\n") if ($n % 8 == 7);
        $n++;
    }
    print($FH "\n") if ($n % 8 != 0);
}
sub output_string_list {
    my ($FH) = shift @_;
    my (@list) = @_;
    my $n = 0;
    foreach my $entry (@list) {
        print($FH "\t") if ($n % 3 == 0);
        printf($FH "%s,", $entry);
        print($FH "\n") if ($n % 3 == 2);
        $n++;
    }
    print($FH "\n") if ($n % 3 != 0);
}
# ------------------------------------------------------------------------------
# Process the internal LIB structure and produce the outputs in the main file
# and the lib specific include file.
# ------------------------------------------------------------------------------
sub PROCESS {
    my $libname = $LIBNAME;
    
    open(FH_LIB, ">ro_${libname}.h") or die $!;
    printf(FH_LIB "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n\n");
    print FH_MAIN "//\n// roTStrings from lib ${libname}\n//\n";

    foreach my $name (sort keys %LIB) {
        my $type = $TYPEMAP{$LIB{$name}{"type"}} or 0;
        my $item = $LIB{$name}{"item"};
        $LIB{$name}{"index"} = $INDEX;
        process_item($name);
        add_string($name, $INDEX++, 0);
    }
#    printf (FH_MAIN "\nextern const ro_TString *ro_list_${libname}[];\n");
#    printf (FH_LIB "extern const ro_TString *ro_list_${libname}[];\n");
    printf (FH_MAIN "const ro_TString *ro_list_${libname}[] = {\n");
    output_list(FH_MAIN, map { $LIB{$_}{"index"} } sort keys %LIB);
    printf (FH_MAIN "};\n");
}

# ------------------------------------------------------------------------------
# Do the extra work needed on a non-baselib lib which is just to add the table
# definition which will be used by the baselib.
# ------------------------------------------------------------------------------
sub PROCESS_LIB {
    PROCESS();
    my $count = keys %LIB;
    my $index = $INDEX++;
}
sub LIB_TABLE {
    my $count = keys %LIB;
    printf(FH_MAIN "\nDEFTABLE(ro_table_${LIBNAME}, ro_list_${LIBNAME}, ${count});\n");
}

# ------------------------------------------------------------------------------
# Process the baselib library, so we do some extra stuff at the end
# ------------------------------------------------------------------------------
sub PROCESS_FINAL {
    PROCESS();

    my $count = keys %LIB;
    my ($minlen, $maxlen) = minmax(keys %LIB);
    printf(FH_MAIN "#define MAX_BASELIB (%d)\n", $count);
    printf(FH_MAIN "#define MIN_BASELIB_LEN (%d)\n", $minlen);
    printf(FH_MAIN "#define MAX_BASELIB_LEN (%d)\n", $maxlen);
    printf(FH_MAIN "\n");
} 

# ------------------------------------------------------------------------------
# Simple hashing function used to creating buckets to make the string search
# a bit quicker, since there are so many of them.
# ------------------------------------------------------------------------------
sub strhash {
    my $str = shift @_;
    my $hash = 0;
    foreach $char (split //, $str) { $hash += ord($char); }
    $hash &= ($BUCKETS - 1);
    return $hash;
}

# ------------------------------------------------------------------------------
# Sort function that uses the hash first and then alphabetical
# ------------------------------------------------------------------------------
sub hashsort ($$) {
    strhash($_[0]) <=> strhash($_[1]) or ($_[0] cmp $_[1]);
}

# ------------------------------------------------------------------------------
# Output the global word list in a form that means we can search it as quickly
# as possible
# ------------------------------------------------------------------------------
sub PROCESS_STRINGS {
    my $count = keys %STRINGS;
    my ($minlen, $maxlen) = minmax(keys %STRINGS);
    my @indexes = map { $STRINGS{$_}{"index"} } sort keys %STRINGS;
    my @list = sort keys %STRINGS;

    printf (FH_MAIN "\nstatic const ro_TString *ro_tstrings[] = {\n");
    output_list(FH_MAIN, @indexes);
    printf (FH_MAIN "};\n");

    # Let's build a start/end mechanism for the first character is each word, it will
    # be a little inefficient for all the __xxx words, but is nice and simple and should
    # speed up detection of things that aren't in the list.
    my @ranges = ();
    for (my $i = 33; $i <= 127; $i++) { $ranges[$i] = { "start"=>-1, "end"=>-1 }; }
    for (my $i=0; $i <= $#list; $i++) {
        my $ch = ord(substr($list[$i], 0, 1));
        die "INVALID CHAR" if ($ch < 33 or $ch > 127);
        $ranges[$ch]{"end"} = $i;
    }
    for (my $i=$#list; $i >= 0; $i--) {
        my $ch = ord(substr($list[$i], 0, 1));
        die "INVALID CHAR" if ($ch < 33 or $ch > 127);
        $ranges[$ch]{"start"} = $i;
    }

    my @list = ();
    for (my $i = 33; $i <= 127; $i++) {
         push (@list, sprintf("{ .start=%d, .end=%d }", $ranges[$i]{"start"}, $ranges[$i]{"end"}));
#         printf(FH_MAIN "\{ .start=%d, .end=%d },\n", $ranges[$i]{"start"}, $ranges[$i]{"end"});
    }
    printf(FH_MAIN "const ro_range ro_range_lookup[] = {\n");
    output_string_list(FH_MAIN, @list);
    printf(FH_MAIN "};\n");

    print("total=$count\n");
    printf(FH_MAIN "#define MIN_ROSTRING_LEN (%d)\n", $minlen);
    printf(FH_MAIN "#define MAX_ROSTRING_LEN (%d)\n", $maxlen);
    printf(FH_MAIN "\n");
}

1;
