#!/usr/bin/perl -w

use Data::Dumper;

#
# Libraries to import ...
#
@LIBS = (
#    {   "name" => "mathlib", 
#        "table" => "math",
#        "source" => "src/lmathlib.c",
#        "match" => "static const luaL_Reg mathlib\\[\\] =" },

#    {   "name" => "strlib", 
#        "table" => "string",
#        "source" => "src/lstrlib.c",
#        "match" => "static const luaL_Reg strlib\\[\\] =" },

    {   "name" => "baselib", 
        "table" => "",
        "source" => "src/lbaselib.c",
        "match" => "static const luaL_Reg base_funcs\\[\\] =" },
);

#
# We keep a list of strings ... it's first come first served as the tokens need to
# stay in this list
#
%STRINGS = ();
$INDEX = 0;
$TOKEN = 1;         # not used if zero

#
# Add a string to the strings list .. don't overwrite if one is already there
#
sub add_string {
    my $string = shift @_;
    my $index = shift @_;
    
    $STRINGS{$string} = $index;
}

#
# Decided not to use buckets, as a quick-find algorithm will find the right string
# with 5 compares maximum and that's much simpler than anything else, we just need

#
# Subroutine for pulling a list from a C source file
#
# Takes the filename, and a startline match expression
#
sub getlist {
    my $filename = shift @_;
    my $match = shift @_;

    open(FH, $filename) or die $!;
    while(<FH>) {
        if($_ =~ $match) {
            last;
        }
    }
    my $code = "(";
    while(<FH>) {
        last if (/};/);
        $code .= $_;
    }
    close(FH);
    $code .= ");";
    my @res = eval($code) or die $!;

    #
    # Now we can add each string to our strings list (this will uniq them)
    #
    foreach my $k (@res) {
        printf(FH_MAIN "const ro_TString ros%03d = ROSTRING(\"%s\", %d);\n", 
                                                            $INDEX, $k, $TOKEN );
        $TOKEN++ if ($TOKEN > 0);
        add_string($k, $INDEX++);
    }
}

sub write_list {
    my %hash = @_;
    my $n = 0;      # for output styile

    foreach $key (sort keys %hash) {
        my $index = $hash{$key};
        print(FH_MAIN "\t") if ($n % 8 == 0);
        printf(FH_MAIN "&ros%03d, ", $index);
        print(FH_MAIN "\n") if ($n % 8 == 7);   
        $n++;
    }
    print(FH_MAIN "\n") if ($n % 8 != 0);
}
# ------------------------------------------------------------------------------
# Given a filename and a structure match, pull out a hash of name vs function
# ------------------------------------------------------------------------------

sub getreg {
    my $libname = shift @_;
    my $filename = shift @_;
    my $match = shift @_;
    my $table = shift @_;
    my %hash = @_ or ();            # for adding to the baselib list

    open(FH_LIB, ">ro_$libname.h") or die $!;
    printf(FH_LIB "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n");
    printf(FH_LIB "\n");   
    print FH_MAIN "//\n// Functions from lib $libname\n//\n";

    open(FH, $filename) or die $!;
    while(<FH>) {
        last if($_ =~ $match);
    }
    while(<FH>) {
        last if (/};/);
        if ( $_ =~ /"([^"]+)",\s+(\w+)/ ) {
            my ($name,$func) = ($1, $2);
            next if $name eq "_VERSION";
            next if $func eq "NULL";

            printf(FH_MAIN "extern const ro_TString ros%03d;\n", $INDEX);
            printf(FH_LIB "extern const ro_TString ros%03d;\n", $INDEX);
            printf(FH_LIB "const ro_TString ros%03d = ROFUNC(\"%s\", %s);\n", 
                                                        $INDEX, $name, $func );
            $hash{$name} = $INDEX;
            add_string($name, $INDEX++, 0);
        }
    }
    close(FH);
    my $count = keys %hash;
    
    #
    # Now write the list...
    #
    printf (FH_MAIN "static const ro_TString *ro_list_${libname}[] = {\n");
    write_list(%hash);
    printf (FH_MAIN "};\n\n");

    if ($libname eq "baselib") {
        my ($minlen, $maxlen) = minmax(keys %hash);
        printf(FH_MAIN "#define MAX_BASELIB (%d)\n", $count);
        printf(FH_MAIN "#define MIN_BASELIB_LEN (%d)\n", $minlen);
        printf(FH_MAIN "#define MAX_BASELIB_LEN (%d)\n", $maxlen);
        printf(FH_MAIN "\n");
        return;
    }
    
    #
    # Now the table and the ROTABLE String
    #
    my $index = $INDEX++;
    printf (FH_MAIN "DEFTABLE(ro_table_${libname}, ro_list_${libname}, $count);\n");
    printf (FH_MAIN "const ro_TString ros%03d = ROTABLE(\"${table}\", &ro_table_${libname});\n", $index);
    printf (FH_MAIN "\n");
    return ( $table => $index );
}

# ------------------------------------------------------------------------------
# Find the minimum and maximum length of the supplied array items
# ------------------------------------------------------------------------------
sub minmax {
    my $min = 999;
    my $max = 0;
    foreach(@_) {
        $min = length($_) if length($_) < $min;
        $max = length($_) if length($_) > $max;
    }
    return ($min, $max);
}


# ------------------------------------------------------------------------------
# Open the main output file and process the tokens and meta methods, these are
# simple outputs and take precident in the STRING list for later.
# ------------------------------------------------------------------------------

open(FH_MAIN, ">ro_main.h") or die $!;
print FH_MAIN "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n\n";

#
# Pull the tokens from llex.c, then stop token counting
#
$TOKEN = 1;
print FH_MAIN "//\n// Tokens from llex.c\n//\n";
getlist("src/llex.c", "luaX_tokens.*\\[\\] =");
$TOKEN = 0;

#
# Pull the meta methods from ltm.c
#
print FH_MAIN "//\n// Metamethods from ltm.c\n//\n";
getlist("src/ltm.c", "luaT_eventname.*\\[\\] =");


#
# Read in data for all of the libraries...
#
my %extras = ();
for my $lib (@LIBS) {
    if ($lib->{"name"} ne "baselib") {
        my %add = getreg($lib->{"name"}, $lib->{"source"}, $lib->{"match"}, $lib->{"table"});
        %extras = ( %extras, %add );
    } else {
        getreg($lib->{"name"}, $lib->{"source"}, $lib->{"match"}, $lib->{"table"}, %extras);
    }
}

#
# Now output the whole word string list...
#
print FH_MAIN "//\n// List of all the read only strings...\n//\n";
printf (FH_MAIN "static const ro_TString *ro_tstrings[] = {\n");
write_list(%STRINGS);
printf (FH_MAIN "};\n\n");
my ($minlen, $maxlen) = minmax(%STRINGS);
my $count = keys %STRINGS;
printf(FH_MAIN "#define MAX_ROSTRINGS (%d)\n", $count);
printf(FH_MAIN "#define MIN_ROSTRING_LEN (%d)\n", $minlen);
printf(FH_MAIN "#define MAX_ROSTRING_LEN (%d)\n", $maxlen);
exit(0);


#
# Now process the individual library include files...
#
for my $l (@LIBS) {
    my $lib = $l->{"name"};
    
    my $count = keys %{$data{"libs"}{$lib}};
    my $table = $l->{"table"};
    my $index = $data{"tables"}{$table};
    print FH_MAIN "//\n// External references for library ${lib}\n//\n";
    write_lib_include($lib);
    next if $lib eq "baselib";

    #
    # Write the searchable list and the table item for the library...
    #   
    printf (FH_MAIN "\n");
    printf (FH_MAIN "static const ro_TString *ro_${lib}_list[] = {\n");
    write_list($lib);
    printf (FH_MAIN "};\n\n");   
    printf (FH_MAIN "DEFTABLE(ro_table_${lib}, ro_list_${lib}, $count);\n");
    printf (FH_MAIN "const ro_TString ros%03d = ROTABLE(\"${table}\", ro_table_${lib});\n", $index);
    printf (FH_MAIN "\n");
    
    #
    # Add it to the baselib list so we pick it up when we write the list out
    #
    $data{"libs"}{"baselib"}{$table} = {
        "index" => $index,
        "token" => 0,
    };
}

#
# Now we can write the baselib list... which needs to be last because it's the global
# list and therefore references the other libraries ROTABLE strings.
#
$count = keys %{$data{"libs"}{"baselib"}};
($minlen, $maxlen) = minmax(keys %{$data{"libs"}{"baselib"}});
print FH_MAIN "//\n// List of strings for baselib\n//\n";
printf (FH_MAIN "static const ro_TString *ro_list_baselib[] = {\n");
write_list("baselib");
printf (FH_MAIN "};\n\n");   
printf(FH_MAIN "#define MAX_ROSTRINGS (%d)\n", $count);
printf(FH_MAIN "#define MIN_ROSTRING_LEN (%d)\n", $minlen);
printf(FH_MAIN "#define MAX_ROSTRING_LEN (%d)\n", $maxlen);

exit 0;

