#!/usr/bin/perl -w

$INDEX = 0;
%STRINGS = ();
%LIB = ();
$LIBNAME = "";

%TYPEMAP=(
    "func" => "LUA_VCCL",
    "table" => "LUA_TTABLE",
    "string" => "LUA_VSHRSTR",
    "float" => "LUA_VNUMFLT",
    "integer" => "LUA_VNUMINT",
);
    
open(FH_MAIN, ">ro_main.h") or die $!;
print FH_MAIN "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n\n";

READ_TOKENS();
READ_WORDS("src/ltm.c", "luaT_eventname[]");

READ_LIB("mathlib", "src/lmathlib.c", "mathlib[]");
ADD_FLOAT("pi", "PI");
ADD_FLOAT("huge", "(lua_Number)HUGE_VAL");
ADD_INT("maxinteger", "LUA_MAXINTEGER");
ADD_INT("mininteger", "LUA_MININTEGER");
PROCESS_LIB();


READ_LIB("baselib", "src/lbaselib.c", "base_funcs[]");
ADD_TABLE("math", "mathlib");
PROCESS_FINAL();

PROCESS_STRINGS();

exit 0;

# ------------------------------------------------------------------------------
# Find the minimum and maximum length of the supplied array items
# ------------------------------------------------------------------------------
sub minmax {
    my $min = 999;
    my $max = 0;
    foreach(@_) {
        $min = length($_) if length($_) < $min;
        $max = length($_) if length($_) > $max;
    }
    return ($min, $max);
}
# ------------------------------------------------------------------------------
# Adds an entry to the overall string list, note it must not replace existing
# entries mainly because the token numbers need to survive in the list lookups
# ------------------------------------------------------------------------------
sub add_string {
    my $string = shift @_;
    my $index = shift @_;

    $STRINGS{$string} = { "index"=>$index } if not exists $STRINGS{$string};
}

# ------------------------------------------------------------------------------
# Reads tokens from a list within a C source file, if $tok is defined then the
# output will include an incrementing token number.
# ------------------------------------------------------------------------------
sub _READWORDS {
    my $file = shift @_;
    my $match = shift @_;
    my $tok = shift @_ or 0;

    open(FH, $file) or die $!;
    while(<FH>) {
        last if($_ =~ /\Q$match\E/);
    }
    my $code = "(";
    while(<FH>) {
        last if (/};/);
        $code .= $_;
    }
    close(FH);
    $code .= ");";
    print($code);
    my @res = eval($code) or die $!;

    #
    # Now we can add each string to our strings list (this will uniq them)
    #
    foreach my $k (@res) {
        printf(FH_MAIN "const ro_TString ros%03d = ROSTRING(\"$k\", $tok, 0, NULL);\n", $INDEX);
        $tok++ if($tok > 0);
        add_string($k, $INDEX++);
    }
}
sub READ_TOKENS {
    return _READWORDS("src/llex.c", "luaX_tokens [] =", 1);
}
sub READ_WORDS {
    return _READWORDS(shift @_, shift @_, 0);
}

# ------------------------------------------------------------------------------
# Reads the strings and functions from the lib source file and stores them in the
# global LIB array (which is zeroed at the start)
# ------------------------------------------------------------------------------
sub READ_LIB {
    my $name = shift @_;
    my $file = shift @_;
    my $match = shift @_;

    %LIB = ();
    $LIBNAME = $name;
    open(FH, $file) or die $!;
    while(<FH>) {
        last if ($_ =~ /\Q$match\E/);
    }
    while(<FH>) {
        last if /};/;
        if ( $_ =~ /"([^"]+)",\s+(\w+)/ ) {
            $LIB{$1} = { "type"=>"func", "item"=>$2 }
        }
    }
    close(FH);
}
# ------------------------------------------------------------------------------
# Functions for adding and removing lib items
# ------------------------------------------------------------------------------
sub ADD_FUNC {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"func", "item"=>$item };
}
sub ADD_FLOAT {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"float", "item"=>$item };
}
sub ADD_INT {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"integer", "item"=>$item };
}
sub ADD_TABLE {
    my ($name, $item) = @_;
    $LIB{$name} = { "type"=>"table", "item"=>$item };
}
# ------------------------------------------------------------------------------
# Process an item in a LIB handling the different types and the creation of other
# objects if needed
# ------------------------------------------------------------------------------
sub process_item {
    my $name = shift @_;
    my $count = keys %LIB;
    my $type = $TYPEMAP{$LIB{$name}{"type"}} or 0;
    my $item = $LIB{$name}{"item"};
    $LIB{$name}{"index"} = $INDEX;
    my $cvar = sprintf("ros%03d", $INDEX);
   
    if ($type eq "LUA_VNUMFLT") {
        printf(FH_LIB "const lua_Number ${cvar}_item = ${item};\n");
        $item = "&${cvar}_item";
    } elsif ($type eq "LUA_VNUMINT") {
        $item = "(void *)$item";
    } elsif ($type eq "LUA_TTABLE") {
        printf(FH_LIB "extern const ro_TString ro_list_${item};\n");
        printf(FH_LIB "extern const Table ro_table_${name};\n");
        printf(FH_LIB "DEFTABLE(ro_table_${name}, &ro_list_${item}, ${count});\n");
        $item = "&ro_table_${name}";
    }
    printf(FH_LIB "extern const ro_TString ros%03d;\n", $INDEX);
    printf(FH_LIB "const ro_TString ros%03d = ROSTRING(\"${name}\", 0, $type, $item);\n", $INDEX);
    printf(FH_MAIN "extern const ro_TString ros%03d;\n", $INDEX);
}

# ------------------------------------------------------------------------------
# Output a list of ros items in sorted order in a nice C friendly way
# ------------------------------------------------------------------------------
sub output_list {
    my ($FH) = shift @_;
    my (%hash) = @_;
    my $n = 0;
    foreach my $key (sort keys %hash) {
        my $index = $hash{$key}{"index"};
        print($FH "\t") if ($n % 8 == 0);
        printf($FH "&ros%03d, ", $index);
        print($FH "\n") if ($n % 8 == 7);
        $n++;
    }
    print($FH "\n") if ($n % 8 != 0);
}
# ------------------------------------------------------------------------------
# Process the internal LIB structure and produce the outputs in the main file
# and the lib specific include file.
# ------------------------------------------------------------------------------
sub PROCESS {
    my $libname = $LIBNAME;
    
    open(FH_LIB, ">ro_${libname}.h") or die $!;
    printf(FH_LIB "//\n// Autogenerated file, use: ./build_rostrings.pl\n//\n\n");
    print FH_MAIN "//\n// roTStrings from lib ${libname}\n//\n";

    foreach my $name (sort keys %LIB) {
        my $type = $TYPEMAP{$LIB{$name}{"type"}} or 0;
        my $item = $LIB{$name}{"item"};
        $LIB{$name}{"index"} = $INDEX;

#        }
        process_item($name);
        add_string($name, $INDEX++, 0);
    }
    printf (FH_MAIN "\nextern const ro_TString *ro_list_${libname}[];\n");
    printf (FH_LIB "extern const ro_TString *ro_list_${libname}[];\n");
    printf (FH_LIB "const ro_TString *ro_list_${libname}[] = {\n");
    output_list(FH_LIB, %LIB);
    printf (FH_LIB "};\n");
}

# ------------------------------------------------------------------------------
# Do the extra work needed on a non-baselib lib which is just to add the table
# definition which will be used by the baselib.
# ------------------------------------------------------------------------------
sub PROCESS_LIB {
    PROCESS();
    my $count = keys %LIB;
    my $index = $INDEX++;
#    printf(FH_MAIN "\nDEFTABLE(ro_table_${LIBNAME}, ro_list_${LIBNAME}, ${count});\n");
}

# ------------------------------------------------------------------------------
# Process the baselib library, so we do some extra stuff at the end
# ------------------------------------------------------------------------------
sub PROCESS_FINAL {
    PROCESS();

    my $count = keys %LIB;
    my ($minlen, $maxlen) = minmax(keys %LIB);
    printf(FH_MAIN "#define MAX_BASELIB (%d)\n", $count);
    printf(FH_MAIN "#define MIN_BASELIB_LEN (%d)\n", $minlen);
    printf(FH_MAIN "#define MAX_BASELIB_LEN (%d)\n", $maxlen);
    printf(FH_MAIN "\n");
} 

# ------------------------------------------------------------------------------
# Output the global word list in a form that means we can search it as quickly
# as possible
# ------------------------------------------------------------------------------
sub PROCESS_STRINGS {
    my $count = keys %STRINGS;
    my ($minlen, $maxlen) = minmax(keys %STRINGS);
    printf (FH_MAIN "\nstatic const ro_TString *ro_tstrings[] = {\n");
    output_list(FH_MAIN, %STRINGS);
    printf (FH_MAIN "};\n");

    my $count = keys %STRINGS;
    my ($minlen, $maxlen) = minmax(keys %STRINGS);
    printf(FH_MAIN "#define MAX_ROSTRINGS (%d)\n", $count);
    printf(FH_MAIN "#define MIN_ROSTRING_LEN (%d)\n", $minlen);
    printf(FH_MAIN "#define MAX_ROSTRING_LEN (%d)\n", $maxlen);
    printf(FH_MAIN "\n");
}
